import crypto from "node:crypto";
import path from "node:path";

import Fastify from "fastify";
import cors from "@fastify/cors";
import staticPlugin from "@fastify/static";
import { z } from "zod";

import { db, migrate } from "./db.js";

const projectSchema = z.object({
  title: z.string().min(1),
  bookType: z.enum(["nonfiction", "policy-legal"]),
  audience: z.string().optional(),
  promise: z.string().optional()
});

const sourceSchema = z.object({
  filename: z.string().min(1),
  sha256: z.string().min(10)
});

const outlineSchema = z.object({
  outlineId: z.string().min(1)
});

const blockUpdateSchema = z.object({
  text: z.string().min(1)
});

const exportSchema = z.object({
  includePlainEnglish: z.boolean().default(false)
});

const exportDir = path.resolve(process.cwd(), "../../data/exports");

export function buildServer() {
  migrate();
  const app = Fastify({ logger: true });

  app.register(cors, { origin: true });
  app.register(staticPlugin, {
    root: exportDir,
    prefix: "/exports/"
  });

  app.get("/health", async () => ({ status: "ok" }));

  app.post("/projects", async (request, reply) => {
    const body = projectSchema.parse(request.body);
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    db.prepare(
      "INSERT INTO projects (id, title, book_type, audience, promise, created_at) VALUES (?, ?, ?, ?, ?, ?)"
    ).run(id, body.title, body.bookType, body.audience ?? null, body.promise ?? null, now);

    reply.code(201).send({ id, ...body, createdAt: now });
  });

  app.post("/projects/:id/sources", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const body = sourceSchema.parse(request.body);
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    db.prepare(
      "INSERT INTO sources (id, project_id, filename, sha256, status, created_at) VALUES (?, ?, ?, ?, ?, ?)"
    ).run(id, projectId, body.filename, body.sha256, "uploaded", now);

    reply.code(201).send({ id, projectId, ...body, status: "uploaded" });
  });

  app.post("/sources/:id/extract", async (request, reply) => {
    const sourceId = z.string().parse(request.params?.id);
    db.prepare("UPDATE sources SET status = ? WHERE id = ?").run("extracted", sourceId);
    reply.send({ sourceId, status: "extracted" });
  });

  app.post("/projects/:id/outline:generate", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const outlines = [
      { id: crypto.randomUUID(), title: "Outline A" },
      { id: crypto.randomUUID(), title: "Outline B" }
    ];

    outlines.forEach((outline, index) => {
      db.prepare(
        "INSERT INTO outline_nodes (id, project_id, parent_id, title, order_index) VALUES (?, ?, ?, ?, ?)"
      ).run(outline.id, projectId, null, outline.title, index + 1);
    });

    reply.send({ projectId, outlines });
  });

  app.post("/projects/:id/draft:generate", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const body = outlineSchema.parse(request.body);
    const now = new Date().toISOString();

    const blockId = crypto.randomUUID();
    db.prepare(
      "INSERT INTO blocks (id, project_id, outline_node_id, type, text, provenance_json, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    ).run(
      blockId,
      projectId,
      body.outlineId,
      "paragraph",
      "Draft text generated by Codex.",
      JSON.stringify({ source: "manual" }),
      now
    );

    reply.send({ projectId, outlineId: body.outlineId, blockId });
  });

  app.patch("/blocks/:id", async (request, reply) => {
    const blockId = z.string().parse(request.params?.id);
    const body = blockUpdateSchema.parse(request.body);

    db.prepare("UPDATE blocks SET text = ? WHERE id = ?").run(body.text, blockId);
    reply.send({ blockId, text: body.text });
  });

  app.post("/projects/:id/plain-english:generate", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const summary = {
      projectId,
      status: "complete",
      message: "Plain-English layer generated with traceability."
    };
    reply.send(summary);
  });

  app.post("/projects/:id/export", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const body = exportSchema.parse(request.body ?? {});
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    const jsonUrl = `/exports/${projectId}/book.json`;
    const jsonlUrl = `/exports/${projectId}/book.jsonl`;
    const pdfUrl = `/exports/${projectId}/book.pdf`;
    const epubUrl = `/exports/${projectId}/book.epub`;

    db.prepare(
      "INSERT INTO exports (id, project_id, pdf_url, epub_url, json_url, jsonl_url, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    ).run(id, projectId, pdfUrl, epubUrl, jsonUrl, jsonlUrl, now);

    reply.send({
      exportId: id,
      includePlainEnglish: body.includePlainEnglish,
      links: { pdfUrl, epubUrl, jsonUrl, jsonlUrl }
    });
  });

  app.get("/projects/:id/exports/latest", async (request, reply) => {
    const projectId = z.string().parse(request.params?.id);
    const exportRow = db
      .prepare(
        "SELECT id, pdf_url as pdfUrl, epub_url as epubUrl, json_url as jsonUrl, jsonl_url as jsonlUrl, created_at as createdAt FROM exports WHERE project_id = ? ORDER BY created_at DESC LIMIT 1"
      )
      .get(projectId);

    if (!exportRow) {
      reply.code(404).send({ message: "No exports yet." });
      return;
    }

    reply.send(exportRow);
  });

  return app;
}
